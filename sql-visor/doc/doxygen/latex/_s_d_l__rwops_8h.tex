\doxysection{C\+:/\+Users/\+Manuel/\+Desktop/\+Avanzada/2\+P\+A\+\_\+\+T\+A\+\_\+alcazarlo/sql-\/visor/deps/sdl2/include/\+S\+D\+L\+\_\+rwops.h File Reference}
\label{_s_d_l__rwops_8h}\index{C:/Users/Manuel/Desktop/Avanzada/2PA\_TA\_alcazarlo/sql-\/visor/deps/sdl2/include/SDL\_rwops.h@{C:/Users/Manuel/Desktop/Avanzada/2PA\_TA\_alcazarlo/sql-\/visor/deps/sdl2/include/SDL\_rwops.h}}
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+stdinc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+error.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}begin\+\_\+code.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}close\+\_\+code.\+h\char`\"{}}\newline
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ S\+D\+L\+\_\+\+R\+Wops}
\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+U\+N\+K\+N\+O\+WN}~0U
\item 
\#define \textbf{ S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+W\+I\+N\+F\+I\+LE}~1U
\item 
\#define \textbf{ S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+S\+T\+D\+F\+I\+LE}~2U
\item 
\#define \textbf{ S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+J\+N\+I\+F\+I\+LE}~3U
\item 
\#define \textbf{ S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+M\+E\+M\+O\+RY}~4U
\item 
\#define \textbf{ S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+RO}~5U
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \textbf{ S\+D\+L\+\_\+\+R\+Wops} \textbf{ S\+D\+L\+\_\+\+R\+Wops}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{Indent}\textbf{ Read endian functions}\par
{\em Read an item of the specified endianness and return in native format. }\begin{DoxyCompactItemize}
\item 
D\+E\+C\+L\+S\+P\+EC Uint8 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Read\+U8} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src)
\item 
D\+E\+C\+L\+S\+P\+EC Uint16 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Read\+L\+E16} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src)
\item 
D\+E\+C\+L\+S\+P\+EC Uint16 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Read\+B\+E16} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src)
\item 
D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Read\+L\+E32} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src)
\item 
D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Read\+B\+E32} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src)
\item 
D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Read\+L\+E64} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src)
\item 
D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Read\+B\+E64} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Write endian functions}\par
{\em Write an item of native format to the specified endianness. }\begin{DoxyCompactItemize}
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Write\+U8} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$dst, Uint8 value)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Write\+L\+E16} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$dst, Uint16 value)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Write\+B\+E16} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$dst, Uint16 value)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Write\+L\+E32} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$dst, Uint32 value)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Write\+B\+E32} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$dst, Uint32 value)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Write\+L\+E64} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$dst, Uint64 value)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Write\+B\+E64} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$dst, Uint64 value)
\end{DoxyCompactItemize}
\end{Indent}
\doxysubsection*{R\+W\+From functions}
\label{_amgrp62de7a3fffaa5d9dd1e07f650daede2b}%
Functions to create \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structures from various data streams. \begin{DoxyCompactItemize}
\item 
\#define \textbf{ R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+S\+ET}~0
\item 
\#define \textbf{ R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+C\+UR}~1
\item 
\#define \textbf{ R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+E\+ND}~2
\item 
D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+W\+From\+File} (const char $\ast$file, const char $\ast$mode)
\item 
D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+W\+From\+FP} (void $\ast$fp, S\+D\+L\+\_\+bool autoclose)
\item 
D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+W\+From\+Mem} (void $\ast$mem, int size)
\item 
D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem} (const void $\ast$mem, int size)
\item 
D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Alloc\+RW} (void)
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Free\+RW} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$area)
\item 
D\+E\+C\+L\+S\+P\+EC Sint64 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+Wsize} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$context)
\item 
D\+E\+C\+L\+S\+P\+EC Sint64 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+Wseek} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$context, Sint64 offset, int whence)
\item 
D\+E\+C\+L\+S\+P\+EC Sint64 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+Wtell} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$context)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+Wread} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$context, void $\ast$ptr, size\+\_\+t size, size\+\_\+t maxnum)
\item 
D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+Wwrite} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$context, const void $\ast$ptr, size\+\_\+t size, size\+\_\+t num)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+R\+Wclose} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$context)
\item 
D\+E\+C\+L\+S\+P\+EC void $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Load\+File\+\_\+\+RW} (\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$src, size\+\_\+t $\ast$datasize, int freesrc)
\item 
D\+E\+C\+L\+S\+P\+EC void $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Load\+File} (const char $\ast$file, size\+\_\+t $\ast$datasize)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This file provides a general interface for S\+DL to read and write data streams. It can easily be extended to files, memory, etc. 

\doxysubsection{Macro Definition Documentation}
\mbox{\label{_s_d_l__rwops_8h_aba5f3b60c197def370ffa2ca1ab1348d}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!RW\_SEEK\_CUR@{RW\_SEEK\_CUR}}
\index{RW\_SEEK\_CUR@{RW\_SEEK\_CUR}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{RW\_SEEK\_CUR}
{\footnotesize\ttfamily \#define R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+C\+UR~1}

Seek relative to current read point \mbox{\label{_s_d_l__rwops_8h_a6cf141faabd1b8f2ec3c03cf76eaf553}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!RW\_SEEK\_END@{RW\_SEEK\_END}}
\index{RW\_SEEK\_END@{RW\_SEEK\_END}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{RW\_SEEK\_END}
{\footnotesize\ttfamily \#define R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+E\+ND~2}

Seek relative to the end of data \mbox{\label{_s_d_l__rwops_8h_ac028b032bb8230df64bc6284e04789f5}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!RW\_SEEK\_SET@{RW\_SEEK\_SET}}
\index{RW\_SEEK\_SET@{RW\_SEEK\_SET}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{RW\_SEEK\_SET}
{\footnotesize\ttfamily \#define R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+S\+ET~0}

Seek from the beginning of data \mbox{\label{_s_d_l__rwops_8h_ad1e973a8b9f9c6cae33f2870c9f76b7d}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWOPS\_JNIFILE@{SDL\_RWOPS\_JNIFILE}}
\index{SDL\_RWOPS\_JNIFILE@{SDL\_RWOPS\_JNIFILE}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWOPS\_JNIFILE}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+J\+N\+I\+F\+I\+LE~3U}

Android asset \mbox{\label{_s_d_l__rwops_8h_a1120765c20af356803b2beb6709e6749}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWOPS\_MEMORY@{SDL\_RWOPS\_MEMORY}}
\index{SDL\_RWOPS\_MEMORY@{SDL\_RWOPS\_MEMORY}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWOPS\_MEMORY}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+M\+E\+M\+O\+RY~4U}

Memory stream \mbox{\label{_s_d_l__rwops_8h_a145dd63b72548f37e2fdd9de8bf15bbc}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWOPS\_MEMORY\_RO@{SDL\_RWOPS\_MEMORY\_RO}}
\index{SDL\_RWOPS\_MEMORY\_RO@{SDL\_RWOPS\_MEMORY\_RO}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWOPS\_MEMORY\_RO}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+RO~5U}

Read-\/\+Only memory stream \mbox{\label{_s_d_l__rwops_8h_a054a717fd0b1a2f175e2e822e1ecc67d}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWOPS\_STDFILE@{SDL\_RWOPS\_STDFILE}}
\index{SDL\_RWOPS\_STDFILE@{SDL\_RWOPS\_STDFILE}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWOPS\_STDFILE}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+S\+T\+D\+F\+I\+LE~2U}

Stdio file \mbox{\label{_s_d_l__rwops_8h_abefd1a35086e97620beffc2c069bd97d}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWOPS\_UNKNOWN@{SDL\_RWOPS\_UNKNOWN}}
\index{SDL\_RWOPS\_UNKNOWN@{SDL\_RWOPS\_UNKNOWN}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWOPS\_UNKNOWN}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+U\+N\+K\+N\+O\+WN~0U}

Unknown stream type \mbox{\label{_s_d_l__rwops_8h_ad979b58d7905cfd8af0bab9ed97c1685}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWOPS\_WINFILE@{SDL\_RWOPS\_WINFILE}}
\index{SDL\_RWOPS\_WINFILE@{SDL\_RWOPS\_WINFILE}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWOPS\_WINFILE}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+R\+W\+O\+P\+S\+\_\+\+W\+I\+N\+F\+I\+LE~1U}

Win32 file 

\doxysubsection{Typedef Documentation}
\mbox{\label{_s_d_l__rwops_8h_af758c42c576a0612bdf298c5823a5fe5}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWops@{SDL\_RWops}}
\index{SDL\_RWops@{SDL\_RWops}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWops}
{\footnotesize\ttfamily typedef struct \textbf{ S\+D\+L\+\_\+\+R\+Wops}  \textbf{ S\+D\+L\+\_\+\+R\+Wops}}

This is the read/write operation structure -- very basic. 

\doxysubsection{Function Documentation}
\mbox{\label{_s_d_l__rwops_8h_a02d04e13c85cd28706b8c3881c32dd46}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_AllocRW@{SDL\_AllocRW}}
\index{SDL\_AllocRW@{SDL\_AllocRW}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_AllocRW()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops}$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Alloc\+RW (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Use this function to allocate an empty, unpopulated \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure.

Applications do not need to use this function unless they are providing their own \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} implementation. If you just need a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} to read/write a common data source, you should use the built-\/in implementations in S\+DL, like \doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File()}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} or \doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem()}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e}, etc.

You must free the returned pointer with \doxyref{S\+D\+L\+\_\+\+Free\+R\+W()}{p.}{_s_d_l__rwops_8h_ac4c87c7bed186ea1a98531164ff1acfa}. Depending on your operating system and compiler, there may be a difference between the malloc() and free() your program uses and the versions S\+DL calls internally. Trying to mix the two can cause crashing such as segmentation faults. Since all \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} must free themselves when their {\bfseries{close}} method is called, all \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} must be allocated through this function, so they can all be freed correctly with \doxyref{S\+D\+L\+\_\+\+Free\+R\+W()}{p.}{_s_d_l__rwops_8h_ac4c87c7bed186ea1a98531164ff1acfa}.

\begin{DoxyReturn}{Returns}
a pointer to the allocated memory on success, or N\+U\+LL on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Free\+RW}{p.}{_s_d_l__rwops_8h_ac4c87c7bed186ea1a98531164ff1acfa} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ac4c87c7bed186ea1a98531164ff1acfa}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_FreeRW@{SDL\_FreeRW}}
\index{SDL\_FreeRW@{SDL\_FreeRW}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_FreeRW()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Free\+RW (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{area }\end{DoxyParamCaption})}

Use this function to free an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure allocated by \doxyref{S\+D\+L\+\_\+\+Alloc\+R\+W()}{p.}{_s_d_l__rwops_8h_a02d04e13c85cd28706b8c3881c32dd46}.

Applications do not need to use this function unless they are providing their own \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} implementation. If you just need a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} to read/write a common data source, you should use the built-\/in implementations in S\+DL, like \doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File()}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} or \doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem()}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e}, etc, and call the {\bfseries{close}} method on those \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} pointers when you are done with them.

Only use \doxyref{S\+D\+L\+\_\+\+Free\+R\+W()}{p.}{_s_d_l__rwops_8h_ac4c87c7bed186ea1a98531164ff1acfa} on pointers returned by \doxyref{S\+D\+L\+\_\+\+Alloc\+R\+W()}{p.}{_s_d_l__rwops_8h_a02d04e13c85cd28706b8c3881c32dd46}. The pointer is invalid as soon as this function returns. Any extra memory allocated during creation of the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} is not freed by \doxyref{S\+D\+L\+\_\+\+Free\+R\+W()}{p.}{_s_d_l__rwops_8h_ac4c87c7bed186ea1a98531164ff1acfa}; the programmer must be responsible for managing that memory in their {\bfseries{close}} method.


\begin{DoxyParams}{Parameters}
{\em area} & the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure to be freed\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Alloc\+RW}{p.}{_s_d_l__rwops_8h_a02d04e13c85cd28706b8c3881c32dd46} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ac259a2d74dfea39864bf3840ee126837}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_LoadFile@{SDL\_LoadFile}}
\index{SDL\_LoadFile@{SDL\_LoadFile}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_LoadFile()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Load\+File (\begin{DoxyParamCaption}\item[{const char $\ast$}]{file,  }\item[{size\+\_\+t $\ast$}]{datasize }\end{DoxyParamCaption})}

Load all the data from a file path.

The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in the value reported via {\ttfamily datasize}.

The data should be freed with S\+D\+L\+\_\+free().


\begin{DoxyParams}{Parameters}
{\em file} & the path to read all available data from \\
\hline
{\em datasize} & if not N\+U\+LL, will store the number of bytes read \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the data, or N\+U\+LL if there was an error. 
\end{DoxyReturn}
\mbox{\label{_s_d_l__rwops_8h_ab80a1b522d2fbbae8ed5610d029fcfda}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_LoadFile\_RW@{SDL\_LoadFile\_RW}}
\index{SDL\_LoadFile\_RW@{SDL\_LoadFile\_RW}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_LoadFile\_RW()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Load\+File\+\_\+\+RW (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src,  }\item[{size\+\_\+t $\ast$}]{datasize,  }\item[{int}]{freesrc }\end{DoxyParamCaption})}

Load all the data from an S\+DL data stream.

The data is allocated with a zero byte at the end (null terminated) for convenience. This extra byte is not included in the value reported via {\ttfamily datasize}.

The data should be freed with S\+D\+L\+\_\+free().


\begin{DoxyParams}{Parameters}
{\em src} & the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} to read all available data from \\
\hline
{\em datasize} & if not N\+U\+LL, will store the number of bytes read \\
\hline
{\em freesrc} & if non-\/zero, calls \doxyref{S\+D\+L\+\_\+\+R\+Wclose()}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} on {\ttfamily src} before returning \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the data, or N\+U\+LL if there was an error. 
\end{DoxyReturn}
\mbox{\label{_s_d_l__rwops_8h_a3cdf85a50e40dc58536930429b7b4d09}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_ReadBE16@{SDL\_ReadBE16}}
\index{SDL\_ReadBE16@{SDL\_ReadBE16}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_ReadBE16()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint16 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Read\+B\+E16 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src }\end{DoxyParamCaption})}

Use this function to read 16 bits of big-\/endian data from an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} and return in native format.

S\+DL byteswaps the data only if necessary, so the data returned will be in the native byte order.


\begin{DoxyParams}{Parameters}
{\em src} & the stream from which to read data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
16 bits of data in the native byte order of the platform.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Read\+L\+E16}{p.}{_s_d_l__rwops_8h_a7274f5c4b6f22a6b742ec6ef4f9d390b} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_af023e134e3ae87b1595306e5faeaab76}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_ReadBE32@{SDL\_ReadBE32}}
\index{SDL\_ReadBE32@{SDL\_ReadBE32}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_ReadBE32()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Read\+B\+E32 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src }\end{DoxyParamCaption})}

Use this function to read 32 bits of big-\/endian data from an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} and return in native format.

S\+DL byteswaps the data only if necessary, so the data returned will be in the native byte order.


\begin{DoxyParams}{Parameters}
{\em src} & the stream from which to read data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
32 bits of data in the native byte order of the platform.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Read\+L\+E32}{p.}{_s_d_l__rwops_8h_a8320334c299a3631fd6beb9937c30f04} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a4917dc584d162bc5f28b63843557214e}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_ReadBE64@{SDL\_ReadBE64}}
\index{SDL\_ReadBE64@{SDL\_ReadBE64}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_ReadBE64()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Read\+B\+E64 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src }\end{DoxyParamCaption})}

Use this function to read 64 bits of big-\/endian data from an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} and return in native format.

S\+DL byteswaps the data only if necessary, so the data returned will be in the native byte order.


\begin{DoxyParams}{Parameters}
{\em src} & the stream from which to read data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
64 bits of data in the native byte order of the platform.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Read\+L\+E64}{p.}{_s_d_l__rwops_8h_af7e5d9b56874b8bd3a8a6a0c5393c33d} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a7274f5c4b6f22a6b742ec6ef4f9d390b}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_ReadLE16@{SDL\_ReadLE16}}
\index{SDL\_ReadLE16@{SDL\_ReadLE16}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_ReadLE16()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint16 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Read\+L\+E16 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src }\end{DoxyParamCaption})}

Use this function to read 16 bits of little-\/endian data from an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} and return in native format.

S\+DL byteswaps the data only if necessary, so the data returned will be in the native byte order.


\begin{DoxyParams}{Parameters}
{\em src} & the stream from which to read data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
16 bits of data in the native byte order of the platform.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Read\+B\+E16}{p.}{_s_d_l__rwops_8h_a3cdf85a50e40dc58536930429b7b4d09} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a8320334c299a3631fd6beb9937c30f04}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_ReadLE32@{SDL\_ReadLE32}}
\index{SDL\_ReadLE32@{SDL\_ReadLE32}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_ReadLE32()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Read\+L\+E32 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src }\end{DoxyParamCaption})}

Use this function to read 32 bits of little-\/endian data from an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} and return in native format.

S\+DL byteswaps the data only if necessary, so the data returned will be in the native byte order.


\begin{DoxyParams}{Parameters}
{\em src} & the stream from which to read data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
32 bits of data in the native byte order of the platform.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Read\+B\+E32}{p.}{_s_d_l__rwops_8h_af023e134e3ae87b1595306e5faeaab76} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_af7e5d9b56874b8bd3a8a6a0c5393c33d}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_ReadLE64@{SDL\_ReadLE64}}
\index{SDL\_ReadLE64@{SDL\_ReadLE64}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_ReadLE64()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Read\+L\+E64 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src }\end{DoxyParamCaption})}

Use this function to read 64 bits of little-\/endian data from an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} and return in native format.

S\+DL byteswaps the data only if necessary, so the data returned will be in the native byte order.


\begin{DoxyParams}{Parameters}
{\em src} & the stream from which to read data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
64 bits of data in the native byte order of the platform.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Read\+B\+E64}{p.}{_s_d_l__rwops_8h_a4917dc584d162bc5f28b63843557214e} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ab864094eb6b80fbf0c77d34ecdde7907}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_ReadU8@{SDL\_ReadU8}}
\index{SDL\_ReadU8@{SDL\_ReadU8}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_ReadU8()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint8 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Read\+U8 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src }\end{DoxyParamCaption})}

Use this function to read a byte from an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}.


\begin{DoxyParams}{Parameters}
{\em src} & the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} to read from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the read byte on success or 0 on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+0.
\end{DoxySince}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Write\+U8}{p.}{_s_d_l__rwops_8h_a07c817f8360ddc8c8983d12373306555} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWclose@{SDL\_RWclose}}
\index{SDL\_RWclose@{SDL\_RWclose}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWclose()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+Wclose (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{context }\end{DoxyParamCaption})}

Close and free an allocated \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure.

\doxyref{S\+D\+L\+\_\+\+R\+Wclose()}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} closes and cleans up the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} stream. It releases any resources used by the stream and frees the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} itself with \doxyref{S\+D\+L\+\_\+\+Free\+R\+W()}{p.}{_s_d_l__rwops_8h_ac4c87c7bed186ea1a98531164ff1acfa}. This returns 0 on success, or -\/1 if the stream failed to flush to its output (e.\+g. to disk).

Note that if this fails to flush the stream to disk, this function reports an error, but the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} is still invalid once this function returns.

\doxyref{S\+D\+L\+\_\+\+R\+Wclose()}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} is actually a macro that calls the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}\textquotesingle{}s {\ttfamily close} method appropriately, to simplify application development.


\begin{DoxyParams}{Parameters}
{\em context} & \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure to close \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or a negative error code on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 

\doxyref{S\+D\+L\+\_\+\+R\+Wwrite}{p.}{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWFromConstMem@{SDL\_RWFromConstMem}}
\index{SDL\_RWFromConstMem@{SDL\_RWFromConstMem}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWFromConstMem()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops}$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem (\begin{DoxyParamCaption}\item[{const void $\ast$}]{mem,  }\item[{int}]{size }\end{DoxyParamCaption})}

Use this function to prepare a read-\/only memory buffer for use with R\+Wops.

This function sets up an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} struct based on a memory area of a certain size. It assumes the memory area is not writable.

Attempting to write to this R\+Wops stream will report an error without writing to the memory buffer.

This memory buffer is not copied by the R\+Wops; the pointer you provide must remain valid until you close the stream. Closing the stream will not free the original buffer.

If you need to write to a memory buffer, you should use \doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem()}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} with a writable buffer of memory instead.


\begin{DoxyParams}{Parameters}
{\em mem} & a pointer to a read-\/only buffer to feed an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} stream \\
\hline
{\em size} & the buffer size, in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a new \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure, or N\+U\+LL if it fails; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 

\doxyref{S\+D\+L\+\_\+\+R\+Wtell}{p.}{_s_d_l__rwops_8h_aade1cc6bf5cd0972c64f1bc032bdece6} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWFromFile@{SDL\_RWFromFile}}
\index{SDL\_RWFromFile@{SDL\_RWFromFile}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWFromFile()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops}$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+W\+From\+File (\begin{DoxyParamCaption}\item[{const char $\ast$}]{file,  }\item[{const char $\ast$}]{mode }\end{DoxyParamCaption})}

Use this function to create a new \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure for reading from and/or writing to a named file.

The {\ttfamily mode} string is treated roughly the same as in a call to the C library\textquotesingle{}s fopen(), even if S\+DL doesn\textquotesingle{}t happen to use fopen() behind the scenes.

Available {\ttfamily mode} strings\+:


\begin{DoxyItemize}
\item \char`\"{}r\char`\"{}\+: Open a file for reading. The file must exist.
\item \char`\"{}w\char`\"{}\+: Create an empty file for writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.
\item \char`\"{}a\char`\"{}\+: Append to a file. Writing operations append data at the end of the file. The file is created if it does not exist.
\item \char`\"{}r+\char`\"{}\+: Open a file for update both reading and writing. The file must exist.
\item \char`\"{}w+\char`\"{}\+: Create an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.
\item \char`\"{}a+\char`\"{}\+: Open a file for reading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations will move it back to the end of file. The file is created if it does not exist.
\end{DoxyItemize}

{\bfseries{N\+O\+TE}}\+: In order to open a file as a binary file, a \char`\"{}b\char`\"{} character has to be included in the {\ttfamily mode} string. This additional \char`\"{}b\char`\"{} character can either be appended at the end of the string (thus making the following compound modes\+: \char`\"{}rb\char`\"{}, \char`\"{}wb\char`\"{}, \char`\"{}ab\char`\"{}, \char`\"{}r+b\char`\"{}, \char`\"{}w+b\char`\"{}, \char`\"{}a+b\char`\"{}) or be inserted between the letter and the \char`\"{}+\char`\"{} sign for the mixed modes (\char`\"{}rb+\char`\"{}, \char`\"{}wb+\char`\"{}, \char`\"{}ab+\char`\"{}). Additional characters may follow the sequence, although they should have no effect. For example, \char`\"{}t\char`\"{} is sometimes appended to make explicit the file is a text file.

This function supports Unicode filenames, but they must be encoded in U\+T\+F-\/8 format, regardless of the underlying operating system.

As a fallback, \doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File()}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} will transparently open a matching filename in an Android app\textquotesingle{}s {\ttfamily assets}.

Closing the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} will close the file handle S\+DL is holding internally.


\begin{DoxyParams}{Parameters}
{\em file} & a U\+T\+F-\/8 string representing the filename to open \\
\hline
{\em mode} & an A\+S\+C\+II string representing the mode to be used for opening the file. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure that is created, or N\+U\+LL on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 

\doxyref{S\+D\+L\+\_\+\+R\+Wtell}{p.}{_s_d_l__rwops_8h_aade1cc6bf5cd0972c64f1bc032bdece6} 

\doxyref{S\+D\+L\+\_\+\+R\+Wwrite}{p.}{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWFromFP@{SDL\_RWFromFP}}
\index{SDL\_RWFromFP@{SDL\_RWFromFP}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWFromFP()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops}$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+W\+From\+FP (\begin{DoxyParamCaption}\item[{void $\ast$}]{fp,  }\item[{S\+D\+L\+\_\+bool}]{autoclose }\end{DoxyParamCaption})}

Use this function to create an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure from a standard I/O file pointer (stdio.\+h\textquotesingle{}s {\ttfamily F\+I\+L\+E$\ast$}).

This function is not available on Windows, since files opened in an application on that platform cannot be used by a dynamically linked library.

On some platforms, the first parameter is a {\ttfamily void$\ast$}, on others, it\textquotesingle{}s a {\ttfamily F\+I\+L\+E$\ast$}, depending on what system headers are available to S\+DL. It is always intended to be the {\ttfamily F\+I\+L\+E$\ast$} type from the C runtime\textquotesingle{}s stdio.\+h.


\begin{DoxyParams}{Parameters}
{\em fp} & the {\ttfamily F\+I\+L\+E$\ast$} that feeds the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} stream \\
\hline
{\em autoclose} & S\+D\+L\+\_\+\+T\+R\+UE to close the {\ttfamily F\+I\+L\+E$\ast$} when closing the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}, S\+D\+L\+\_\+\+F\+A\+L\+SE to leave the {\ttfamily F\+I\+L\+E$\ast$} open when the R\+Wops is closed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure that is created, or N\+U\+LL on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 

\doxyref{S\+D\+L\+\_\+\+R\+Wtell}{p.}{_s_d_l__rwops_8h_aade1cc6bf5cd0972c64f1bc032bdece6} 

\doxyref{S\+D\+L\+\_\+\+R\+Wwrite}{p.}{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWFromMem@{SDL\_RWFromMem}}
\index{SDL\_RWFromMem@{SDL\_RWFromMem}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWFromMem()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+R\+Wops}$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+W\+From\+Mem (\begin{DoxyParamCaption}\item[{void $\ast$}]{mem,  }\item[{int}]{size }\end{DoxyParamCaption})}

Use this function to prepare a read-\/write memory buffer for use with \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}.

This function sets up an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} struct based on a memory area of a certain size, for both read and write access.

This memory buffer is not copied by the R\+Wops; the pointer you provide must remain valid until you close the stream. Closing the stream will not free the original buffer.

If you need to make sure the R\+Wops never writes to the memory buffer, you should use \doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem()}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} with a read-\/only buffer of memory instead.


\begin{DoxyParams}{Parameters}
{\em mem} & a pointer to a buffer to feed an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} stream \\
\hline
{\em size} & the buffer size, in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a new \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure, or N\+U\+LL if it fails; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 

\doxyref{S\+D\+L\+\_\+\+R\+Wtell}{p.}{_s_d_l__rwops_8h_aade1cc6bf5cd0972c64f1bc032bdece6} 

\doxyref{S\+D\+L\+\_\+\+R\+Wwrite}{p.}{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWread@{SDL\_RWread}}
\index{SDL\_RWread@{SDL\_RWread}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWread()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+Wread (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{context,  }\item[{void $\ast$}]{ptr,  }\item[{size\+\_\+t}]{size,  }\item[{size\+\_\+t}]{maxnum }\end{DoxyParamCaption})}

Read from a data source.

This function reads up to {\ttfamily maxnum} objects each of size {\ttfamily size} from the data source to the area pointed at by {\ttfamily ptr}. This function may read less objects than requested. It will return zero when there has been an error or the data stream is completely read.

\doxyref{S\+D\+L\+\_\+\+R\+Wread()}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} is actually a function wrapper that calls the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}\textquotesingle{}s {\ttfamily read} method appropriately, to simplify application development.


\begin{DoxyParams}{Parameters}
{\em context} & a pointer to an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure \\
\hline
{\em ptr} & a pointer to a buffer to read data into \\
\hline
{\em size} & the size of each object to read, in bytes \\
\hline
{\em maxnum} & the maximum number of objects to be read \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of objects read, or 0 at error or end of file; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 

\doxyref{S\+D\+L\+\_\+\+R\+Wwrite}{p.}{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWseek@{SDL\_RWseek}}
\index{SDL\_RWseek@{SDL\_RWseek}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWseek()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Sint64 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+Wseek (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{context,  }\item[{Sint64}]{offset,  }\item[{int}]{whence }\end{DoxyParamCaption})}

Seek within an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} data stream.

This function seeks to byte {\ttfamily offset}, relative to {\ttfamily whence}.

{\ttfamily whence} may be any of the following values\+:


\begin{DoxyItemize}
\item {\ttfamily R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+S\+ET}\+: seek from the beginning of data
\item {\ttfamily R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+C\+UR}\+: seek relative to current read point
\item {\ttfamily R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+E\+ND}\+: seek relative to the end of data
\end{DoxyItemize}

If this stream can not seek, it will return -\/1.

\doxyref{S\+D\+L\+\_\+\+R\+Wseek()}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} is actually a wrapper function that calls the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}\textquotesingle{}s {\ttfamily seek} method appropriately, to simplify application development.


\begin{DoxyParams}{Parameters}
{\em context} & a pointer to an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure \\
\hline
{\em offset} & an offset in bytes, relative to {\bfseries{whence}} location; can be negative \\
\hline
{\em whence} & any of {\ttfamily R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+S\+ET}, {\ttfamily R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+C\+UR}, {\ttfamily R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+E\+ND} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the final offset in the data stream after the seek or -\/1 on error.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wtell}{p.}{_s_d_l__rwops_8h_aade1cc6bf5cd0972c64f1bc032bdece6} 

\doxyref{S\+D\+L\+\_\+\+R\+Wwrite}{p.}{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ab311e9e01e66dde338349b5988008f79}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWsize@{SDL\_RWsize}}
\index{SDL\_RWsize@{SDL\_RWsize}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWsize()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Sint64 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+Wsize (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{context }\end{DoxyParamCaption})}

Use this macro to get the size of the data stream in an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}.


\begin{DoxyParams}{Parameters}
{\em context} & the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} to get the size of the data stream from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the size of the data stream in the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} on success, -\/1 if unknown or a negative error code on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+0. 
\end{DoxySince}
\mbox{\label{_s_d_l__rwops_8h_aade1cc6bf5cd0972c64f1bc032bdece6}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWtell@{SDL\_RWtell}}
\index{SDL\_RWtell@{SDL\_RWtell}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWtell()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Sint64 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+Wtell (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{context }\end{DoxyParamCaption})}

Determine the current read/write offset in an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} data stream.

S\+D\+L\+\_\+\+R\+Wtell is actually a wrapper function that calls the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}\textquotesingle{}s {\ttfamily seek} method, with an offset of 0 bytes from {\ttfamily R\+W\+\_\+\+S\+E\+E\+K\+\_\+\+C\+UR}, to simplify application development.


\begin{DoxyParams}{Parameters}
{\em context} & a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} data stream object from which to get the current offset \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the current offset in the stream, or -\/1 if the information can not be determined.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 

\doxyref{S\+D\+L\+\_\+\+R\+Wwrite}{p.}{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ada3c6d29d2fc5f0367abdcbfc2f2896a}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_RWwrite@{SDL\_RWwrite}}
\index{SDL\_RWwrite@{SDL\_RWwrite}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_RWwrite()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+R\+Wwrite (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{context,  }\item[{const void $\ast$}]{ptr,  }\item[{size\+\_\+t}]{size,  }\item[{size\+\_\+t}]{num }\end{DoxyParamCaption})}

Write to an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} data stream.

This function writes exactly {\ttfamily num} objects each of size {\ttfamily size} from the area pointed at by {\ttfamily ptr} to the stream. If this fails for any reason, it\textquotesingle{}ll return less than {\ttfamily num} to demonstrate how far the write progressed. On success, it returns {\ttfamily num}.

S\+D\+L\+\_\+\+R\+Wwrite is actually a function wrapper that calls the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}\textquotesingle{}s {\ttfamily write} method appropriately, to simplify application development.


\begin{DoxyParams}{Parameters}
{\em context} & a pointer to an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} structure \\
\hline
{\em ptr} & a pointer to a buffer containing data to write \\
\hline
{\em size} & the size of an object to write, in bytes \\
\hline
{\em num} & the number of objects to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of objects written, which will be less than {\bfseries{num}} on error; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+R\+Wclose}{p.}{_s_d_l__rwops_8h_a4e432d6d008ad176b7653b4797de12e9} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Const\+Mem}{p.}{_s_d_l__rwops_8h_a51b4be80c4647e8a473b6b9fed03b1a6} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+File}{p.}{_s_d_l__rwops_8h_aef7e843c3486bd1770667a594aa0b439} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+FP}{p.}{_s_d_l__rwops_8h_abbd4eda76f330b5c4b813238affbe7a8} 

\doxyref{S\+D\+L\+\_\+\+R\+W\+From\+Mem}{p.}{_s_d_l__rwops_8h_ae6f34841ce63d08597477558ffc0278e} 

\doxyref{S\+D\+L\+\_\+\+R\+Wread}{p.}{_s_d_l__rwops_8h_a7496ce8759fe964ee40cd6fbfa4b82f9} 

\doxyref{S\+D\+L\+\_\+\+R\+Wseek}{p.}{_s_d_l__rwops_8h_a2bd3bfec48d375b5e761a5f7f3138766} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ab84ea778a5f8f76cd73a52216c2c08f5}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_WriteBE16@{SDL\_WriteBE16}}
\index{SDL\_WriteBE16@{SDL\_WriteBE16}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_WriteBE16()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Write\+B\+E16 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{dst,  }\item[{Uint16}]{value }\end{DoxyParamCaption})}

Use this function to write 16 bits in native format to a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} as big-\/endian data.

S\+DL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-\/endian format.


\begin{DoxyParams}{Parameters}
{\em dst} & the stream to which data will be written \\
\hline
{\em value} & the data to be written, in native format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on successful write, 0 on error.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Write\+L\+E16}{p.}{_s_d_l__rwops_8h_aa4a7df8d967c5751e3f0974743b9c2d4} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a5debf04eeed819018ddd9a2f70d32c89}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_WriteBE32@{SDL\_WriteBE32}}
\index{SDL\_WriteBE32@{SDL\_WriteBE32}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_WriteBE32()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Write\+B\+E32 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{dst,  }\item[{Uint32}]{value }\end{DoxyParamCaption})}

Use this function to write 32 bits in native format to a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} as big-\/endian data.

S\+DL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-\/endian format.


\begin{DoxyParams}{Parameters}
{\em dst} & the stream to which data will be written \\
\hline
{\em value} & the data to be written, in native format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on successful write, 0 on error.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Write\+L\+E32}{p.}{_s_d_l__rwops_8h_a84f37961925773fe8b06ea09ed144568} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a0422f79e1889750cf99310e968cb76fc}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_WriteBE64@{SDL\_WriteBE64}}
\index{SDL\_WriteBE64@{SDL\_WriteBE64}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_WriteBE64()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Write\+B\+E64 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{dst,  }\item[{Uint64}]{value }\end{DoxyParamCaption})}

Use this function to write 64 bits in native format to a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} as big-\/endian data.

S\+DL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in big-\/endian format.


\begin{DoxyParams}{Parameters}
{\em dst} & the stream to which data will be written \\
\hline
{\em value} & the data to be written, in native format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on successful write, 0 on error.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Write\+L\+E64}{p.}{_s_d_l__rwops_8h_ae4f9b45fbb3bf4a40f3f308419307e6b} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_aa4a7df8d967c5751e3f0974743b9c2d4}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_WriteLE16@{SDL\_WriteLE16}}
\index{SDL\_WriteLE16@{SDL\_WriteLE16}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_WriteLE16()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Write\+L\+E16 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{dst,  }\item[{Uint16}]{value }\end{DoxyParamCaption})}

Use this function to write 16 bits in native format to a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} as little-\/endian data.

S\+DL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-\/endian format.


\begin{DoxyParams}{Parameters}
{\em dst} & the stream to which data will be written \\
\hline
{\em value} & the data to be written, in native format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on successful write, 0 on error.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Write\+B\+E16}{p.}{_s_d_l__rwops_8h_ab84ea778a5f8f76cd73a52216c2c08f5} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a84f37961925773fe8b06ea09ed144568}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_WriteLE32@{SDL\_WriteLE32}}
\index{SDL\_WriteLE32@{SDL\_WriteLE32}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_WriteLE32()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Write\+L\+E32 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{dst,  }\item[{Uint32}]{value }\end{DoxyParamCaption})}

Use this function to write 32 bits in native format to a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} as little-\/endian data.

S\+DL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-\/endian format.


\begin{DoxyParams}{Parameters}
{\em dst} & the stream to which data will be written \\
\hline
{\em value} & the data to be written, in native format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on successful write, 0 on error.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Write\+B\+E32}{p.}{_s_d_l__rwops_8h_a5debf04eeed819018ddd9a2f70d32c89} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_ae4f9b45fbb3bf4a40f3f308419307e6b}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_WriteLE64@{SDL\_WriteLE64}}
\index{SDL\_WriteLE64@{SDL\_WriteLE64}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_WriteLE64()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Write\+L\+E64 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{dst,  }\item[{Uint64}]{value }\end{DoxyParamCaption})}

Use this function to write 64 bits in native format to a \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} as little-\/endian data.

S\+DL byteswaps the data only if necessary, so the application always specifies native format, and the data written will be in little-\/endian format.


\begin{DoxyParams}{Parameters}
{\em dst} & the stream to which data will be written \\
\hline
{\em value} & the data to be written, in native format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on successful write, 0 on error.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Write\+B\+E64}{p.}{_s_d_l__rwops_8h_a0422f79e1889750cf99310e968cb76fc} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__rwops_8h_a07c817f8360ddc8c8983d12373306555}} 
\index{SDL\_rwops.h@{SDL\_rwops.h}!SDL\_WriteU8@{SDL\_WriteU8}}
\index{SDL\_WriteU8@{SDL\_WriteU8}!SDL\_rwops.h@{SDL\_rwops.h}}
\doxysubsubsection{SDL\_WriteU8()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC size\+\_\+t S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Write\+U8 (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{dst,  }\item[{Uint8}]{value }\end{DoxyParamCaption})}

Use this function to write a byte to an \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops}.


\begin{DoxyParams}{Parameters}
{\em dst} & the \doxyref{S\+D\+L\+\_\+\+R\+Wops}{p.}{struct_s_d_l___r_wops} to write to \\
\hline
{\em value} & the byte value to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on success or 0 on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+0.
\end{DoxySince}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Read\+U8}{p.}{_s_d_l__rwops_8h_ab864094eb6b80fbf0c77d34ecdde7907} 
\end{DoxySeeAlso}
