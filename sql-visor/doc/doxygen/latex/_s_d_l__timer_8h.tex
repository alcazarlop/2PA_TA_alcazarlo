\doxysection{C\+:/\+Users/\+Manuel/\+Desktop/\+Avanzada/2\+P\+A\+\_\+\+T\+A\+\_\+alcazarlo/sql-\/visor/deps/sdl2/include/\+S\+D\+L\+\_\+timer.h File Reference}
\label{_s_d_l__timer_8h}\index{C:/Users/Manuel/Desktop/Avanzada/2PA\_TA\_alcazarlo/sql-\/visor/deps/sdl2/include/SDL\_timer.h@{C:/Users/Manuel/Desktop/Avanzada/2PA\_TA\_alcazarlo/sql-\/visor/deps/sdl2/include/SDL\_timer.h}}
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+stdinc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+error.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}begin\+\_\+code.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}close\+\_\+code.\+h\char`\"{}}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ S\+D\+L\+\_\+\+T\+I\+C\+K\+S\+\_\+\+P\+A\+S\+S\+ED}(A,  B)~((Sint32)((B) -\/ (A)) $<$= 0)
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef Uint32(S\+D\+L\+C\+A\+LL $\ast$ \textbf{ S\+D\+L\+\_\+\+Timer\+Callback}) (Uint32 interval, void $\ast$param)
\item 
typedef int \textbf{ S\+D\+L\+\_\+\+Timer\+ID}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Get\+Ticks} (void)
\item 
D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Get\+Performance\+Counter} (void)
\item 
D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Get\+Performance\+Frequency} (void)
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Delay} (Uint32 ms)
\item 
D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+Timer\+ID} S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Add\+Timer} (Uint32 interval, \textbf{ S\+D\+L\+\_\+\+Timer\+Callback} callback, void $\ast$param)
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+bool S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Remove\+Timer} (\textbf{ S\+D\+L\+\_\+\+Timer\+ID} id)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Header for the S\+DL time management routines. 

\doxysubsection{Macro Definition Documentation}
\mbox{\label{_s_d_l__timer_8h_a5cc109e24ba0c46f6becb28353cd8921}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_TICKS\_PASSED@{SDL\_TICKS\_PASSED}}
\index{SDL\_TICKS\_PASSED@{SDL\_TICKS\_PASSED}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_TICKS\_PASSED}
{\footnotesize\ttfamily \#define S\+D\+L\+\_\+\+T\+I\+C\+K\+S\+\_\+\+P\+A\+S\+S\+ED(\begin{DoxyParamCaption}\item[{}]{A,  }\item[{}]{B }\end{DoxyParamCaption})~((Sint32)((B) -\/ (A)) $<$= 0)}

Compare S\+DL ticks values, and return true if {\ttfamily A} has passed {\ttfamily B}.

For example, if you want to wait 100 ms, you could do this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{Uint32 timeout = SDL\_GetTicks() + 100;}
\DoxyCodeLine{\textcolor{keywordflow}{while} (!SDL\_TICKS\_PASSED(SDL\_GetTicks(), timeout)) \{}
\DoxyCodeLine{    \textcolor{comment}{// ... do work until timeout has elapsed}}
\DoxyCodeLine{\}}
\end{DoxyCode}


Note that this does not handle tick differences greater than 2$^\wedge$31 so take care when using the above kind of code with large timeout delays (tens of days). 

\doxysubsection{Typedef Documentation}
\mbox{\label{_s_d_l__timer_8h_a3c5c867db975d245e4a82fcf0cd7de80}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_TimerCallback@{SDL\_TimerCallback}}
\index{SDL\_TimerCallback@{SDL\_TimerCallback}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_TimerCallback}
{\footnotesize\ttfamily typedef Uint32(S\+D\+L\+C\+A\+LL $\ast$ S\+D\+L\+\_\+\+Timer\+Callback) (Uint32 interval, void $\ast$param)}

Function prototype for the timer callback function.

The callback function is passed the current timer interval and returns the next timer interval. If the returned value is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. If the callback returns 0, the periodic alarm is cancelled. \mbox{\label{_s_d_l__timer_8h_a412e8ff8a6c89615ba8f9486b292213a}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_TimerID@{SDL\_TimerID}}
\index{SDL\_TimerID@{SDL\_TimerID}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_TimerID}
{\footnotesize\ttfamily typedef int \textbf{ S\+D\+L\+\_\+\+Timer\+ID}}

Definition of the timer ID type. 

\doxysubsection{Function Documentation}
\mbox{\label{_s_d_l__timer_8h_a56ceea49587e3fa5796b2e4bf85603b8}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_AddTimer@{SDL\_AddTimer}}
\index{SDL\_AddTimer@{SDL\_AddTimer}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_AddTimer()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC \textbf{ S\+D\+L\+\_\+\+Timer\+ID} S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Add\+Timer (\begin{DoxyParamCaption}\item[{Uint32}]{interval,  }\item[{\textbf{ S\+D\+L\+\_\+\+Timer\+Callback}}]{callback,  }\item[{void $\ast$}]{param }\end{DoxyParamCaption})}

Call a callback function at a future time.

If you use this function, you must pass {\ttfamily S\+D\+L\+\_\+\+I\+N\+I\+T\+\_\+\+T\+I\+M\+ER} to \doxyref{S\+D\+L\+\_\+\+Init()}{p.}{_s_d_l_8h_a8fc8d35348d7c74bad8392d776c937b8}.

The callback function is passed the current timer interval and the user supplied parameter from the \doxyref{S\+D\+L\+\_\+\+Add\+Timer()}{p.}{_s_d_l__timer_8h_a56ceea49587e3fa5796b2e4bf85603b8} call and should return the next timer interval. If the value returned from the callback is 0, the timer is canceled.

The callback is run on a separate thread.

Timers take into account the amount of time it took to execute the callback. For example, if the callback took 250 ms to execute and returned 1000 (ms), the timer would only wait another 750 ms before its next iteration.

Timing may be inexact due to OS scheduling. Be sure to note the current time with \doxyref{S\+D\+L\+\_\+\+Get\+Ticks()}{p.}{_s_d_l__timer_8h_a0b9bc71d6287e0ffafdc3419760fe2b3} or \doxyref{S\+D\+L\+\_\+\+Get\+Performance\+Counter()}{p.}{_s_d_l__timer_8h_a2dbeb63c4f0564811a4adf3938808977} in case your callback needs to adjust for variances.


\begin{DoxyParams}{Parameters}
{\em interval} & the timer delay, in milliseconds, passed to {\ttfamily callback} \\
\hline
{\em callback} & the S\+D\+L\+\_\+\+Timer\+Callback function to call when the specified {\ttfamily interval} elapses \\
\hline
{\em param} & a pointer that is passed to {\ttfamily callback} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a timer ID or 0 if an error occurs; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Remove\+Timer}{p.}{_s_d_l__timer_8h_afe8d418e59a24ae6ad820b92137ab9b2} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__timer_8h_ae8050b95373b95249064467592ab4e21}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_Delay@{SDL\_Delay}}
\index{SDL\_Delay@{SDL\_Delay}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_Delay()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Delay (\begin{DoxyParamCaption}\item[{Uint32}]{ms }\end{DoxyParamCaption})}

Wait a specified number of milliseconds before returning.

This function waits a specified number of milliseconds before returning. It waits at least the specified time, but possibly longer due to OS scheduling.


\begin{DoxyParams}{Parameters}
{\em ms} & the number of milliseconds to delay \\
\hline
\end{DoxyParams}
\mbox{\label{_s_d_l__timer_8h_a2dbeb63c4f0564811a4adf3938808977}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_GetPerformanceCounter@{SDL\_GetPerformanceCounter}}
\index{SDL\_GetPerformanceCounter@{SDL\_GetPerformanceCounter}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_GetPerformanceCounter()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Get\+Performance\+Counter (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Get the current value of the high resolution counter.

This function is typically used for profiling.

The counter values are only meaningful relative to each other. Differences between values can be converted to times by using \doxyref{S\+D\+L\+\_\+\+Get\+Performance\+Frequency()}{p.}{_s_d_l__timer_8h_a507ebea12e31dacc9f85f7d9febe0efb}.

\begin{DoxyReturn}{Returns}
the current counter value.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Get\+Performance\+Frequency}{p.}{_s_d_l__timer_8h_a507ebea12e31dacc9f85f7d9febe0efb} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__timer_8h_a507ebea12e31dacc9f85f7d9febe0efb}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_GetPerformanceFrequency@{SDL\_GetPerformanceFrequency}}
\index{SDL\_GetPerformanceFrequency@{SDL\_GetPerformanceFrequency}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_GetPerformanceFrequency()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint64 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Get\+Performance\+Frequency (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Get the count per second of the high resolution counter.

\begin{DoxyReturn}{Returns}
a platform-\/specific count per second.
\end{DoxyReturn}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+0.
\end{DoxySince}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Get\+Performance\+Counter}{p.}{_s_d_l__timer_8h_a2dbeb63c4f0564811a4adf3938808977} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__timer_8h_a0b9bc71d6287e0ffafdc3419760fe2b3}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_GetTicks@{SDL\_GetTicks}}
\index{SDL\_GetTicks@{SDL\_GetTicks}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_GetTicks()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC Uint32 S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Get\+Ticks (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Get the number of milliseconds since S\+DL library initialization.

This value wraps if the program runs for more than $\sim$49 days.

\begin{DoxyReturn}{Returns}
an unsigned 32-\/bit value representing the number of milliseconds since the S\+DL library initialized.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+T\+I\+C\+K\+S\+\_\+\+P\+A\+S\+S\+ED}{p.}{_s_d_l__timer_8h_a5cc109e24ba0c46f6becb28353cd8921} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__timer_8h_afe8d418e59a24ae6ad820b92137ab9b2}} 
\index{SDL\_timer.h@{SDL\_timer.h}!SDL\_RemoveTimer@{SDL\_RemoveTimer}}
\index{SDL\_RemoveTimer@{SDL\_RemoveTimer}!SDL\_timer.h@{SDL\_timer.h}}
\doxysubsubsection{SDL\_RemoveTimer()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+bool S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Remove\+Timer (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+Timer\+ID}}]{id }\end{DoxyParamCaption})}

Remove a timer created with \doxyref{S\+D\+L\+\_\+\+Add\+Timer()}{p.}{_s_d_l__timer_8h_a56ceea49587e3fa5796b2e4bf85603b8}.


\begin{DoxyParams}{Parameters}
{\em id} & the ID of the timer to remove \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\+D\+L\+\_\+\+T\+R\+UE if the timer is removed or S\+D\+L\+\_\+\+F\+A\+L\+SE if the timer wasn\textquotesingle{}t found.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Add\+Timer}{p.}{_s_d_l__timer_8h_a56ceea49587e3fa5796b2e4bf85603b8} 
\end{DoxySeeAlso}
