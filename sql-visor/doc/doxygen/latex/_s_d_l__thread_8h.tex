\doxysection{C\+:/\+Users/\+Manuel/\+Desktop/\+Avanzada/2\+P\+A\+\_\+\+T\+A\+\_\+alcazarlo/sql-\/visor/deps/sdl2/include/\+S\+D\+L\+\_\+thread.h File Reference}
\label{_s_d_l__thread_8h}\index{C:/Users/Manuel/Desktop/Avanzada/2PA\_TA\_alcazarlo/sql-\/visor/deps/sdl2/include/SDL\_thread.h@{C:/Users/Manuel/Desktop/Avanzada/2PA\_TA\_alcazarlo/sql-\/visor/deps/sdl2/include/SDL\_thread.h}}
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+stdinc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+error.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+atomic.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+mutex.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}begin\+\_\+code.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}close\+\_\+code.\+h\char`\"{}}\newline
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{_s_d_l__thread_8h_a97cd1dc60cea74b74273affb1a974db5}} 
typedef struct S\+D\+L\+\_\+\+Thread {\bfseries S\+D\+L\+\_\+\+Thread}
\item 
\mbox{\label{_s_d_l__thread_8h_ac4db699531ce9f18f5a8547aa988b88e}} 
typedef unsigned long {\bfseries S\+D\+L\+\_\+thread\+ID}
\item 
\mbox{\label{_s_d_l__thread_8h_a07ce005c35ad6ac377d6124db7296026}} 
typedef unsigned int {\bfseries S\+D\+L\+\_\+\+T\+L\+S\+ID}
\item 
typedef int(S\+D\+L\+C\+A\+LL $\ast$ \textbf{ S\+D\+L\+\_\+\+Thread\+Function}) (void $\ast$data)
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ S\+D\+L\+\_\+\+Thread\+Priority} \{ {\bfseries S\+D\+L\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+P\+R\+I\+O\+R\+I\+T\+Y\+\_\+\+L\+OW}, 
{\bfseries S\+D\+L\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+P\+R\+I\+O\+R\+I\+T\+Y\+\_\+\+N\+O\+R\+M\+AL}, 
{\bfseries S\+D\+L\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+P\+R\+I\+O\+R\+I\+T\+Y\+\_\+\+H\+I\+GH}, 
{\bfseries S\+D\+L\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+P\+R\+I\+O\+R\+I\+T\+Y\+\_\+\+T\+I\+M\+E\+\_\+\+C\+R\+I\+T\+I\+C\+AL}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+\+Thread $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Create\+Thread} (\textbf{ S\+D\+L\+\_\+\+Thread\+Function} fn, const char $\ast$name, void $\ast$data)
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+\+Thread $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Create\+Thread\+With\+Stack\+Size} (\textbf{ S\+D\+L\+\_\+\+Thread\+Function} fn, const char $\ast$name, const size\+\_\+t stacksize, void $\ast$data)
\item 
const D\+E\+C\+L\+S\+P\+EC char $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Get\+Thread\+Name} (S\+D\+L\+\_\+\+Thread $\ast$thread)
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+thread\+ID S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Thread\+ID} (void)
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+thread\+ID S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Get\+Thread\+ID} (S\+D\+L\+\_\+\+Thread $\ast$thread)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Set\+Thread\+Priority} (\textbf{ S\+D\+L\+\_\+\+Thread\+Priority} priority)
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Wait\+Thread} (S\+D\+L\+\_\+\+Thread $\ast$thread, int $\ast$status)
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+Detach\+Thread} (S\+D\+L\+\_\+\+Thread $\ast$thread)
\item 
D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+\+T\+L\+S\+ID S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+T\+L\+S\+Create} (void)
\item 
D\+E\+C\+L\+S\+P\+EC void $\ast$S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+T\+L\+S\+Get} (S\+D\+L\+\_\+\+T\+L\+S\+ID id)
\item 
D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+T\+L\+S\+Set} (S\+D\+L\+\_\+\+T\+L\+S\+ID id, const void $\ast$value, void(S\+D\+L\+C\+A\+LL $\ast$destructor)(void $\ast$))
\item 
D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL \textbf{ S\+D\+L\+\_\+\+T\+L\+S\+Cleanup} (void)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Header for the S\+DL thread management routines. 

\doxysubsection{Typedef Documentation}
\mbox{\label{_s_d_l__thread_8h_a35d10c50423c326b20abea6a486f53e0}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_ThreadFunction@{SDL\_ThreadFunction}}
\index{SDL\_ThreadFunction@{SDL\_ThreadFunction}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_ThreadFunction}
{\footnotesize\ttfamily typedef int(S\+D\+L\+C\+A\+LL $\ast$ S\+D\+L\+\_\+\+Thread\+Function) (void $\ast$data)}

The function passed to \doxyref{S\+D\+L\+\_\+\+Create\+Thread()}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082}.


\begin{DoxyParams}{Parameters}
{\em data} & what was passed as {\ttfamily data} to \doxyref{S\+D\+L\+\_\+\+Create\+Thread()}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a value that can be reported through \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705}. 
\end{DoxyReturn}


\doxysubsection{Enumeration Type Documentation}
\mbox{\label{_s_d_l__thread_8h_acce8dea56f6b307fadd2949b64e3ebda}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_ThreadPriority@{SDL\_ThreadPriority}}
\index{SDL\_ThreadPriority@{SDL\_ThreadPriority}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_ThreadPriority}
{\footnotesize\ttfamily enum \textbf{ S\+D\+L\+\_\+\+Thread\+Priority}}

The S\+DL thread priority.

S\+DL will make system changes as necessary in order to apply the thread priority. Code which attempts to control thread state related to priority should be aware that calling S\+D\+L\+\_\+\+Set\+Thread\+Priority may alter such state. S\+D\+L\+\_\+\+H\+I\+N\+T\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+P\+R\+I\+O\+R\+I\+T\+Y\+\_\+\+P\+O\+L\+I\+CY can be used to control aspects of this behavior.

\begin{DoxyNote}{Note}
On many systems you require special privileges to set high or time critical priority. 
\end{DoxyNote}


\doxysubsection{Function Documentation}
\mbox{\label{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_CreateThread@{SDL\_CreateThread}}
\index{SDL\_CreateThread@{SDL\_CreateThread}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_CreateThread()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+\+Thread$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Create\+Thread (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+Thread\+Function}}]{fn,  }\item[{const char $\ast$}]{name,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}

Create a new thread with a default stack size.

This is equivalent to calling\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{SDL\_CreateThreadWithStackSize(fn, name, 0, data);}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em fn} & the S\+D\+L\+\_\+\+Thread\+Function function to call in the new thread \\
\hline
{\em name} & the name of the thread \\
\hline
{\em data} & a pointer that is passed to {\ttfamily fn} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an opaque pointer to the new thread object on success, N\+U\+LL if the new thread could not be created; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Create\+Thread\+With\+Stack\+Size}{p.}{_s_d_l__thread_8h_a4bee261cd43d1e25ba75a89fff9fe75d} 

\doxyref{S\+D\+L\+\_\+\+Wait\+Thread}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_a4bee261cd43d1e25ba75a89fff9fe75d}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_CreateThreadWithStackSize@{SDL\_CreateThreadWithStackSize}}
\index{SDL\_CreateThreadWithStackSize@{SDL\_CreateThreadWithStackSize}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_CreateThreadWithStackSize()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+\+Thread$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Create\+Thread\+With\+Stack\+Size (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+Thread\+Function}}]{fn,  }\item[{const char $\ast$}]{name,  }\item[{const size\+\_\+t}]{stacksize,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})}

Create a new thread with a specific stack size.

S\+DL makes an attempt to report {\ttfamily name} to the system, so that debuggers can display it. Not all platforms support this.

Thread naming is a little complicated\+: Most systems have very small limits for the string length (Haiku has 32 bytes, Linux currently has 16, Visual C++ 6.\+0 has {\itshape nine}!), and possibly other arbitrary rules. You\textquotesingle{}ll have to see what happens with your system\textquotesingle{}s debugger. The name should be U\+T\+F-\/8 (but using the naming limits of C identifiers is a better bet). There are no requirements for thread naming conventions, so long as the string is null-\/terminated U\+T\+F-\/8, but these guidelines are helpful in choosing a name\+:

{\texttt{ https\+://stackoverflow.\+com/questions/149932/naming-\/conventions-\/for-\/threads}}

If a system imposes requirements, S\+DL will try to munge the string for it (truncate, etc), but the original string contents will be available from \doxyref{S\+D\+L\+\_\+\+Get\+Thread\+Name()}{p.}{_s_d_l__thread_8h_ae4c44291edec3a1958b4913196516b15}.

The size (in bytes) of the new stack can be specified. Zero means \char`\"{}use the
system default\char`\"{} which might be wildly different between platforms. x86 Linux generally defaults to eight megabytes, an embedded device might be a few kilobytes instead. You generally need to specify a stack that is a multiple of the system\textquotesingle{}s page size (in many cases, this is 4 kilobytes, but check your system documentation).

In S\+DL 2.\+1, stack size will be folded into the original S\+D\+L\+\_\+\+Create\+Thread function, but for backwards compatibility, this is currently a separate function.


\begin{DoxyParams}{Parameters}
{\em fn} & the S\+D\+L\+\_\+\+Thread\+Function function to call in the new thread \\
\hline
{\em name} & the name of the thread \\
\hline
{\em stacksize} & the size, in bytes, to allocate for the new thread stack. \\
\hline
{\em data} & a pointer that is passed to {\ttfamily fn} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an opaque pointer to the new thread object on success, N\+U\+LL if the new thread could not be created; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Wait\+Thread}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_af90602c51ef5a62f26ed9931af484906}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_DetachThread@{SDL\_DetachThread}}
\index{SDL\_DetachThread@{SDL\_DetachThread}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_DetachThread()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Detach\+Thread (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+\+Thread $\ast$}]{thread }\end{DoxyParamCaption})}

Let a thread clean up on exit without intervention.

A thread may be \char`\"{}detached\char`\"{} to signify that it should not remain until another thread has called \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} on it. Detaching a thread is useful for long-\/running threads that nothing needs to synchronize with or further manage. When a detached thread is done, it simply goes away.

There is no way to recover the return code of a detached thread. If you need this, don\textquotesingle{}t detach the thread and instead use \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705}.

Once a thread is detached, you should usually assume the S\+D\+L\+\_\+\+Thread isn\textquotesingle{}t safe to reference again, as it will become invalid immediately upon the detached thread\textquotesingle{}s exit, instead of remaining until someone has called \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} to finally clean it up. As such, don\textquotesingle{}t detach the same thread more than once.

If a thread has already exited when passed to \doxyref{S\+D\+L\+\_\+\+Detach\+Thread()}{p.}{_s_d_l__thread_8h_af90602c51ef5a62f26ed9931af484906}, it will stop waiting for a call to \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} and clean up immediately. It is not safe to detach a thread that might be used with \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705}.

You may not call \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} on a thread that has been detached. Use either that function or this one, but not both, or behavior is undefined.

It is safe to pass N\+U\+LL to this function; it is a no-\/op.


\begin{DoxyParams}{Parameters}
{\em thread} & the S\+D\+L\+\_\+\+Thread pointer that was returned from the \doxyref{S\+D\+L\+\_\+\+Create\+Thread()}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082} call that started this thread\\
\hline
\end{DoxyParams}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+2.
\end{DoxySince}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Create\+Thread}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082} 

\doxyref{S\+D\+L\+\_\+\+Wait\+Thread}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_a0bf5d93ed5cb25ea59307472c62c66db}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_GetThreadID@{SDL\_GetThreadID}}
\index{SDL\_GetThreadID@{SDL\_GetThreadID}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_GetThreadID()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+thread\+ID S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Get\+Thread\+ID (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+\+Thread $\ast$}]{thread }\end{DoxyParamCaption})}

Get the thread identifier for the specified thread.

This thread identifier is as reported by the underlying operating system. If S\+DL is running on a platform that does not support threads the return value will always be zero.


\begin{DoxyParams}{Parameters}
{\em thread} & the thread to query \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the ID of the specified thread, or the ID of the current thread if {\ttfamily thread} is N\+U\+LL.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Thread\+ID}{p.}{_s_d_l__thread_8h_a341933eef1470789de20b05c1392b9ae} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_ae4c44291edec3a1958b4913196516b15}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_GetThreadName@{SDL\_GetThreadName}}
\index{SDL\_GetThreadName@{SDL\_GetThreadName}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_GetThreadName()}
{\footnotesize\ttfamily const D\+E\+C\+L\+S\+P\+EC char$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Get\+Thread\+Name (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+\+Thread $\ast$}]{thread }\end{DoxyParamCaption})}

Get the thread name as it was specified in \doxyref{S\+D\+L\+\_\+\+Create\+Thread()}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082}.

This is internal memory, not to be freed by the caller, and remains valid until the specified thread is cleaned up by \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705}.


\begin{DoxyParams}{Parameters}
{\em thread} & the thread to query \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a U\+T\+F-\/8 string that names the specified thread, or N\+U\+LL if it doesn\textquotesingle{}t have a name.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Create\+Thread}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_adf4da9c0e6a6833bef9741344b09699d}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_SetThreadPriority@{SDL\_SetThreadPriority}}
\index{SDL\_SetThreadPriority@{SDL\_SetThreadPriority}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_SetThreadPriority()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Set\+Thread\+Priority (\begin{DoxyParamCaption}\item[{\textbf{ S\+D\+L\+\_\+\+Thread\+Priority}}]{priority }\end{DoxyParamCaption})}

Set the priority for the current thread.

Note that some platforms will not let you alter the priority (or at least, promote the thread to a higher priority) at all, and some require you to be an administrator account. Be prepared for this to fail.


\begin{DoxyParams}{Parameters}
{\em priority} & the S\+D\+L\+\_\+\+Thread\+Priority to set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or a negative error code on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information. 
\end{DoxyReturn}
\mbox{\label{_s_d_l__thread_8h_a341933eef1470789de20b05c1392b9ae}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_ThreadID@{SDL\_ThreadID}}
\index{SDL\_ThreadID@{SDL\_ThreadID}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_ThreadID()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+thread\+ID S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Thread\+ID (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Get the thread identifier for the current thread.

This thread identifier is as reported by the underlying operating system. If S\+DL is running on a platform that does not support threads the return value will always be zero.

This function also returns a valid thread ID when called from the main thread.

\begin{DoxyReturn}{Returns}
the ID of the current thread.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Get\+Thread\+ID}{p.}{_s_d_l__thread_8h_a0bf5d93ed5cb25ea59307472c62c66db} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_addd72a8ba431ef92685bbc9c89c5c67c}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_TLSCleanup@{SDL\_TLSCleanup}}
\index{SDL\_TLSCleanup@{SDL\_TLSCleanup}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_TLSCleanup()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+T\+L\+S\+Cleanup (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Cleanup all T\+LS data for this thread. \mbox{\label{_s_d_l__thread_8h_ac7ed1ec8dec5b902da25b60da2b728fa}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_TLSCreate@{SDL\_TLSCreate}}
\index{SDL\_TLSCreate@{SDL\_TLSCreate}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_TLSCreate()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC S\+D\+L\+\_\+\+T\+L\+S\+ID S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+T\+L\+S\+Create (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Create a piece of thread-\/local storage.

This creates an identifier that is globally visible to all threads but refers to data that is thread-\/specific.

\begin{DoxyReturn}{Returns}
the newly created thread local storage identifier or 0 on error.
\end{DoxyReturn}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+0.
\end{DoxySince}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+T\+L\+S\+Get}{p.}{_s_d_l__thread_8h_ab519f8d89ea808f32fc139071e6207bb} 

\doxyref{S\+D\+L\+\_\+\+T\+L\+S\+Set}{p.}{_s_d_l__thread_8h_a807c8306201205c7c3ac0cb34ac7cd77} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_ab519f8d89ea808f32fc139071e6207bb}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_TLSGet@{SDL\_TLSGet}}
\index{SDL\_TLSGet@{SDL\_TLSGet}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_TLSGet()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void$\ast$ S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+T\+L\+S\+Get (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+\+T\+L\+S\+ID}]{id }\end{DoxyParamCaption})}

Get the current thread\textquotesingle{}s value associated with a thread local storage ID.


\begin{DoxyParams}{Parameters}
{\em id} & the thread local storage ID \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the value associated with the ID for the current thread or N\+U\+LL if no value has been set; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+0.
\end{DoxySince}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+T\+L\+S\+Create}{p.}{_s_d_l__thread_8h_ac7ed1ec8dec5b902da25b60da2b728fa} 

\doxyref{S\+D\+L\+\_\+\+T\+L\+S\+Set}{p.}{_s_d_l__thread_8h_a807c8306201205c7c3ac0cb34ac7cd77} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_a807c8306201205c7c3ac0cb34ac7cd77}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_TLSSet@{SDL\_TLSSet}}
\index{SDL\_TLSSet@{SDL\_TLSSet}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_TLSSet()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC int S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+T\+L\+S\+Set (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+\+T\+L\+S\+ID}]{id,  }\item[{const void $\ast$}]{value,  }\item[{void(S\+D\+L\+C\+A\+LL $\ast$destructor)(void $\ast$)}]{ }\end{DoxyParamCaption})}

Set the current thread\textquotesingle{}s value associated with a thread local storage ID.

The function prototype for {\ttfamily destructor} is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} destructor(\textcolor{keywordtype}{void} *value)}
\end{DoxyCode}


where its parameter {\ttfamily value} is what was passed as {\ttfamily value} to \doxyref{S\+D\+L\+\_\+\+T\+L\+S\+Set()}{p.}{_s_d_l__thread_8h_a807c8306201205c7c3ac0cb34ac7cd77}.


\begin{DoxyParams}{Parameters}
{\em id} & the thread local storage ID \\
\hline
{\em value} & the value to associate with the ID for the current thread \\
\hline
{\em destructor} & a function called when the thread exits, to free the value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or a negative error code on failure; call \doxyref{S\+D\+L\+\_\+\+Get\+Error()}{p.}{_s_d_l__error_8h_af3cc615dad0d5ed6b36cb84cab15ecb6} for more information.
\end{DoxyReturn}
\begin{DoxySince}{Since}
This function is available since S\+DL 2.\+0.\+0.
\end{DoxySince}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+T\+L\+S\+Create}{p.}{_s_d_l__thread_8h_ac7ed1ec8dec5b902da25b60da2b728fa} 

\doxyref{S\+D\+L\+\_\+\+T\+L\+S\+Get}{p.}{_s_d_l__thread_8h_ab519f8d89ea808f32fc139071e6207bb} 
\end{DoxySeeAlso}
\mbox{\label{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705}} 
\index{SDL\_thread.h@{SDL\_thread.h}!SDL\_WaitThread@{SDL\_WaitThread}}
\index{SDL\_WaitThread@{SDL\_WaitThread}!SDL\_thread.h@{SDL\_thread.h}}
\doxysubsubsection{SDL\_WaitThread()}
{\footnotesize\ttfamily D\+E\+C\+L\+S\+P\+EC void S\+D\+L\+C\+A\+LL S\+D\+L\+\_\+\+Wait\+Thread (\begin{DoxyParamCaption}\item[{S\+D\+L\+\_\+\+Thread $\ast$}]{thread,  }\item[{int $\ast$}]{status }\end{DoxyParamCaption})}

Wait for a thread to finish.

Threads that haven\textquotesingle{}t been detached will remain (as a \char`\"{}zombie\char`\"{}) until this function cleans them up. Not doing so is a resource leak.

Once a thread has been cleaned up through this function, the S\+D\+L\+\_\+\+Thread that references it becomes invalid and should not be referenced again. As such, only one thread may call \doxyref{S\+D\+L\+\_\+\+Wait\+Thread()}{p.}{_s_d_l__thread_8h_ac96743626ed21d2cdb0868a23cca9705} on another.

The return code for the thread function is placed in the area pointed to by {\ttfamily status}, if {\ttfamily status} is not N\+U\+LL.

You may not wait on a thread that has been used in a call to \doxyref{S\+D\+L\+\_\+\+Detach\+Thread()}{p.}{_s_d_l__thread_8h_af90602c51ef5a62f26ed9931af484906}. Use either that function or this one, but not both, or behavior is undefined.

It is safe to pass a N\+U\+LL thread to this function; it is a no-\/op.

Note that the thread pointer is freed by this function and is not valid afterward.


\begin{DoxyParams}{Parameters}
{\em thread} & the S\+D\+L\+\_\+\+Thread pointer that was returned from the \doxyref{S\+D\+L\+\_\+\+Create\+Thread()}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082} call that started this thread \\
\hline
{\em status} & pointer to an integer that will receive the value returned from the thread function by its \textquotesingle{}return\textquotesingle{}, or N\+U\+LL to not receive such value back.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Create\+Thread}{p.}{_s_d_l__thread_8h_aca3013d4f50e918b17d2721b37e59082} 

\doxyref{S\+D\+L\+\_\+\+Detach\+Thread}{p.}{_s_d_l__thread_8h_af90602c51ef5a62f26ed9931af484906} 
\end{DoxySeeAlso}
